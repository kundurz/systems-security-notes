# Data Execution Prevention

#### Shellcode Mitigation: the "No-eXecute" bit 
* Modern architectures support memory permissions
	* `PROT_READ` allows the process to read memory
	* `PROT_WRITE` allows the process to write memory
	* `PROT_EXEC` allows the process to execute memory
* Intuition: *normally*, all code is located in `.text` segments of the loaded ELF files.
	* There is no need to execute code located on the stack or in the heap. 
* By default in modern operating systems, the stack and the heap are not executable
* But your shellcode needs to execute D: 
* This has made shellcode rarer. It is now an ancient art
	* Its still very much around in embedded devices
#### Remaining Injection Points - de-protecting memory
* Memory can be made executable using `mprotect()` system call:
	1. Trick the program into `mprotect(PROT_EXEC)`ing our shellcode
	2. Jump to the shellcode. 
* How do we do #1?
	* Most common way is *code reuse* through *Return Oriented Programming*.
	* other cases are situational, depending on what the program is designed to do.

#### Remaining Injection Points - JIT
* Just in TIme compilers need to generate (and frequently re-generate) code that is executed.
* Pages must be writable for code generation.
* Pages must be executable for exeuction.
* Because syscalls are slow and the point of JIT is to be fast, a shortcut is taken in which some pages are both writable and executable at the same time. 
	* So some of these programs have a writable and executable page in memory. This is a place where shellcode can be injected. 
	* I believe regular code memory is not writable. Just readable and executable. 
* Shellcode injection technique: JIT spraying:
	* Make constants in the code that will be JITed 
	* The JIT engine will `mprotect(PROT_WRITE)`
