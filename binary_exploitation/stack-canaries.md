# Stack Canaries

#### Introduction
* To fight buffer overflows into return address, researchers introduced stack canareies
	1. In function prologue, write random vlaue at the end of the stack frame
	2. In function epilogue, make sure this value is still intact 
* If an overflow messed up the canary, you just kill the whole program. 
* `checksec --file=file_name` can tell you whether the executable has stack canaries enabled 
* i think there might be a canary check after every read... Maybe?

#### Stack Canaries
* Stack canaries are VERY effective in general.
* Situtational bypass methods:
	1. Leak the canary (using another vulnerability)
	2. Brute-force the canary (for forking processes). 
		* You can leak the canary byte by byte
```c
int main() {
char buf [16];
while (1) {
	if (fork()) { wait(0); }
	else { read(0, buf, 128); return; }
}
}
```
	
3. Jumping the canary (if situation allows)
```c
int main() {
char buf[16]; 
int i; 
for (i = 0; i < 12; i++) read(0, buf+i, 1);
}
```
* you can overwrite into `i` and it will read at whatever offset you want. But the compiler might not lay out the stack like this. You would have to get really lucky. 
	
* Depending on the stack layout, you can overwrite `i` and redirect the read to point to *after* the canary!
* A subtle thing you should keep in mind is that the check is not for if the canary was overwritten, its for if it was changed, so you can overwrite it with itself and you should be fine. 
