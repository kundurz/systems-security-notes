# shellcode injection

* A Von Neumann architecture sees (and stores) code as data.
* A Harvard architecture stores data and code separately. 
* Almost all general-purpose architectures (x86, ARM, MIPS, PPC, SPARC, etc) are Von Neumann
* Harvard architectures pop up in embdedded use-cases (AVR, PIC)
* What happens if data and code get mixed up

#### How does shellcode get injected?
```c
void bye1() { puts("Goodbye!"); }
void bye2() { puts("Farwell!"); }
void hello(char *name, void (*bye_func)()) 
{
	printf("Hello %s!\n", name); 
	bye_func(); 
}

int main() 
{
	char name[1024];
	gets(name); 
	srand(time(0)); 
	if (rand() % 2) hello(bye1, name); // arguments mixed up 
	else hello(name, bye2); 

	return 0; 
}
```

#### Security Concept: Code Injection
* Code injection was used in one of the earliest documented exploits: the Morris worm. 
	* Among other attack vectors, overflowed stack buffer in the `fingerd` service
	* Injected shellcode to gain a foothold on the machine
	* Scanned adjacent hosts and infected them to propogate the worm
	* *Shut down the internet*

#### Why "shell"code
* Usually the goal of an exploit is to achieve arbitrary command execution. 
* A typical attack goal is to launch a shell: `execve("/bin/sh", NULL, NULL);`
* Thus "shellcode."
* Shellcode can have many different goals, other than just dropping a shell. 

#### Building Shellcode
* Write your shellcode as assembly
* Then, assemble it!
	* `gcc -nostdlib -static shellcode.s -o shellcode-elf`
* This is an ELF with your shellcode as its `.text`. You still need to extract it:
	* `objcopy --dump-section .text=shellcode-raw shellcode-elf`
* The resulting shellcode-raw file contains the raw bytes of your shellcode. This is what you would inject as part of your exploits.

#### Running Shellcode (replicating exotic conditons)
* If you need to replicate exotic conditions in ways that are too hard to do as a preamble for your shellcode, you can build a shellcode loader in C

#### Debugging Shellcode: strace
* To see if things are working from a high level, you can trace your shellcode with `strace`
	* `gcc -nostdlib -static shellcode.s -o shellcode-elf

#### Debugging Shellcode: gdb
* Your shellcode-elf is a Linux program, and you can debug it in gdb
	* `gdb ./shellcode-elf`
* Caveats:
	* There is no source code to display and navigate 
	* You'll have to print instructions doing stuff like `x/gx $rip`

#### Shellcode for other architectures
* One way of building shellcode translates well to other architectures


