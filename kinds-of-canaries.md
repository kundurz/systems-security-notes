# Canaries

* A mitigation to counter buffer overflows.
* Assumes that no matter how careful we are in writing our code, there will always be unknown bugs which might be exploited by the attacker before they are fixed. 
* Exploits a limitation of stack-based buffer overflows, which is that the attacker must overwrite every single byte from the start of the buffer to the piece of control data they want to modify.
* The idea is to  place the canary between the overflowed buffer and the control data of each function stack frame. 
	* This means the attacker will overwrite the canary before nay control data. 
* The program will check the state of the canary before trusting any of the control data

#### Canary-enabled prologue
* Pushes the canary onto the stack, immediately after the control data and before the allocation of local variables. 

#### Canary-enabled epilogue
* Checks that the canary still contains the original value
* If the canary has been changed, a possible attack has been detected and process should be aborted
	* Turns a bug that could lead to a compromise of the process's credentials into a more benign denial of service

## Kinds of Canaries
####  Random
* The canary is a random number, unknown to the attacker
* Good if the attacker cannot guess them
* Memory leak bugs can reveal the canary's value, rendering them useless
#### Terminator
* The canary contains characters that stop most string functions (newline, null byte, linefeed, -1)
* Constant and well-known to the attacker. 
* This is great because the attacker cannot make the canary's value a part of their input and if they overwrite it with something else, the attack is detected.
* Unfortunately, there are bugs that involve `memcpy()`, `read()`, or even custom hand-made code, and these bugs are either not blocked by any particular byte value, or by characters that are not int he canary 

#### XOR
* The canary is the xor of a random value and the saved return address
* Merging the original stored rip address with the random canary
* A memory leak can reveal both the XOR canary and the stored rip address, thus exposing the random value and so on. 

* Canaries can be, and often have been defeated by memory leaks and/or attacks that do not rely on stack-based buffer overflows (ex: format string vulnerabilities)

## Implementation
* Linux systems that use the GNU C library and `gcc` (i.e., most of the Linux systems) implement stack canaries as a collaboration between the kernel, the compiler and the C library.
	1.  During each `execve()`, the kernel places a random value in the stack of the new virtual memory
	2. The C runtime initialization functions that come with the GNU libc use this value to compute the canary and place it in a well known location in the process's memory. 
	3. The function prologue generated by `gcc` takes this global canary and pushes it on the stack; the function epilogue checks if the local canary matches the global one, and aborts the process if they differ.
* The canary is always the same for the entire lifetime of the process.
* There is a new canary only when `execve()` is called: a `fork()`ed process will use the same canary as its parent. 
* The canary resides in many places in memory: there always is the global copy and, at any given moment, there is a copy in the stack frames of all currently active functions.
* Other copies, coming from previously returned functions may be found in uninitialized variables of currently active functions. The attacker only needs a memory leak bug, in any part of the program, that she can use to read any of these copies. 
* Note that the attacker now has to find two exploitable bugs instead of one, so the mitigation reduces the attacker's chances somewhat

#### The Kernel
* Upon completion of the `execve()` system call, the kernel puts 16 random bytes on the stack, typically just anove the argument and environment strings. 
* It then puts a pointer to these bytes into an entry of the auxiliary vector. This is a data structure the kernel pushes onto the process stack, just below the environment array

#### The GNU C library
* Contains some object files that are linked with all programs by default
* Contain the C runtime initialization and cleanup routines
* The `_start` entry point of our program is defined in one of these fules
* The function performs many initializations and then calls our `main()`. Among these initializations 
* Among these initializations there is the creation of the canary value, which is very simple: The canary coincides with the least significant bbytes of the random number generated bbyt he kernel. However, the least significant byte is replaced by 0. 
* Therefore, the canary is a mixture of a "terminator" and a "random" canary. Note that this means on 32-bit systems this means that only 3 bytes are random, which makes it not difficult to guess by brute forcing
* There is still another place where the canary can be (essentially) read: the random value stored by the kernel on the stack. 
* The canary is stored in the Thread Control Block (TCB). This is a per-thread data structure used by standard libraries to hold information that depends on the current thread. 
* For the entire lifetime of a thread, a pointer to this structure is contained in the (hidden part of ) the `fs` register. 
	* This is one of the two `segment selector` registers (the other is `gs`) that are still in use on the AMG64 architecture. They contain a constant virtual address that can be added to any memory operand address. 
	* The `fs` register is initialized by `__libc_start_main`

#### The gcc compiler
* Will add canary support to the compiled program if the `stack-protector` option is enabled. 
* In current linux distros this is enabled by default
* When canaries are enabled, the prologue of canary-protected functions becomes:
```asm
1 ; save the old frame pointer
2 push rbp
3 ; (maybe push other registers)
4 ; create the new frame pointer
5 mov rbp, rsp
6 ; reserve space for the local variables + the canary
7 sub rsp, x
8 ; copy the global canary in the current frame
9 mov rax, QWORD PTR fs:0x28
10 mov QWORD PTR [rbp-8], rax
```
* Lines 1-7 contain the standard prologue, except for the need to reserve space for the canary in addition to the local variables
* Lines 9 and 10 are new: line 9 reads the global canary from offset 0x28 in the TCB and line 10 copies the canary just above the saved frame pointer. 
* Note that if the compiler has to save other registers besides the old frame, the canary will be stored above them.
* The canary epilogue becomes:
```asm
1 ; compare the global canary with the local copy  
2 mov rax, QWORD PTR [rbp-8]  
3 sub rax, QWORD PTR fs:0x28  
4 je good  
5 ; abort if the local canary has been modified  
6 call __stack_chk_fail@plt ; doesnâ€™t return  
7 good:  
8 ; restore old rsp and rbp  
9 leave  
10 ; return to the caller  
11 ret
```
* Lines 1--7 are standard epilogue. 
* The new instructions add a bit of overhead to the function, so gcc only adds them where it thinks they are really needed.
* The `__stack_chk_fail` function prints an error message on standard error and aborts the process. 
* `@plt` suffix is referring to the linker-generated plt table



